import { useState, useEffect } from 'react';

export interface Task {
    id: number;
    title: string;
    content: string;
    status: 'pending' | 'completed'; // strict typing
}

export const useTasks = () => {
    const [tasks, setTasks] = useState<Task[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const API_URL = "http://localhost:4000/v1/tasks";

    // Helper to fetch data
    const fetchTasks = async () => {
        setLoading(true);
        try {
            const res = await fetch(API_URL);
            if (!res.ok) throw new Error("Failed to fetch tasks");
            
            const data = await res.json();
            setTasks(data.tasks || []);
            setError(null);
        } catch (err) {
            setError((err as Error).message);
        } finally {
            setLoading(false);
        }
    };

    // Initial Load
    useEffect(() => {
        fetchTasks();
    }, []);

    // 1. Create Task
    const addTask = async (title: string, content: string) => {
        // Optimistic update could go here, but for creation, waiting is usually okay
        try {
            const res = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title, content, status: 'pending' }),
            });
            if (!res.ok) throw new Error("Failed to create task");
            
            // Re-fetch to get the ID generated by the DB
            fetchTasks(); 
        } catch (err) {
            setError((err as Error).message);
        }
    };

    // 2. Delete Task (Optimistic)
    const deleteTask = async (id: number) => {
        const previousTasks = [...tasks]; // Backup current state

        // Optimistically remove from UI immediately
        setTasks(prev => prev.filter(t => t.id !== id));

        try {
            const res = await fetch(`${API_URL}/${id}`, { method: 'DELETE' });
            if (!res.ok) throw new Error("Failed to delete");
            // If success, do nothing (UI is already updated)
        } catch (err) {
            setError((err as Error).message);
            setTasks(previousTasks); // Rollback on error
        }
    };

    // 3. Toggle Status (Optimistic)
    const toggleStatus = async (task: Task) => {
        const previousTasks = [...tasks]; // Backup
        const newStatus = task.status === 'completed' ? 'pending' : 'completed';

        // Optimistically update UI
        setTasks(prev => prev.map(t => 
            t.id === task.id ? { ...t, status: newStatus } : t
        ));

        try {
            const res = await fetch(`${API_URL}/${task.id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: newStatus }),
            });
            if (!res.ok) throw new Error("Failed to update");
        } catch (err) {
            setError((err as Error).message);
            setTasks(previousTasks); // Rollback
        }
    };

    return { tasks, loading, error, addTask, deleteTask, toggleStatus, refresh: fetchTasks };
};